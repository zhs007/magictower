# 项目概要：魔塔 (Project Tower)

## 1. 项目目标

开发一款基于 Pixi.js 和 TypeScript 的网页版魔塔类游戏。游戏核心玩法是玩家在俯视视角的迷宫中探索，通过策略性地击败怪物、收集道具和钥匙来不断挑战更高层。游戏为竖屏手机端设计，无随机性，强调资源管理的策略规划。

## 2. 核心设计原则

- **逻辑与渲染彻底分离**: 游戏核心逻辑（状态管理、战斗计算、道具效果）必须独立于渲染引擎。逻辑层不应包含任何 Pixi.js 或 DOM 的引用，以便未来能轻松迁移到客户端-服务器架构。
- **模块化**: 代码按功能划分为独立的模块/包（例如：`core-logic`, `renderer`, `data-management`）。单个文件不应过大，保持高内聚、低耦合。
- **数据驱动**: 所有游戏数据（怪物属性、道具效果、地图布局）均由外部 JSON 文件定义，方便策划调整数值和关卡设计。
- **确定性**: 游戏不包含任何随机因素。玩家以相同的顺序执行相同的操作，必须产生完全相同的结果。
- **可测试性**: 核心逻辑部分必须有高覆盖率的单元测试（目标 > 90%），以保证游戏规则的正确性和稳定性。
- **完整的类型定义**: 所有代码必须使用 TypeScript，并提供完整的类型定义，以增强代码的可维护性和健壮性。
- **详尽的注释**: 为关键函数、类和复杂的逻辑块编写清晰的 JSDoc 注释。

## 3. 技术栈

- **渲染引擎**: Pixi.js (最新版)
- **开发语言**: TypeScript
- **构建/打包工具**: Vite (推荐，启动快，支持 TS)
- **测试框架**: Vitest 或 Jest
- **代码规范**: ESLint + Prettier

## 4. 目录结构

```
.
├── assets/              # 游戏资源 (图片)
│   ├── item/
│   ├── map/
│   └── monster/
├── gamedata/            # 游戏数据配置 (JSON)
│   ├── buffs/           # 增益效果配置
│   ├── equipments/      # 装备配置
│   ├── items/           # 道具配置
│   └── monsters/        # 怪物配置
├── jules/               # Jules 的开发计划文件
│   ├── plan001.md
│   └── ...
├── mapdata/             # 地图数据 (JSON)
│   └── floor_01.json
├── public/              # 静态文件
├── src/                 # 源码
│   ├── core/            # 核心逻辑 (无渲染)
│   │   ├── state.ts     # 状态管理
│   │   ├── types.ts     # 核心类型定义
│   │   ├── logic.ts     # 战斗、道具等逻辑
│   │   └── tests/       # 单元测试
│   ├── data/            # 数据加载和管理
│   │   └── data-manager.ts
│   ├── renderer/        # 渲染层 (Pixi.js)
│   │   ├── renderer.ts
│   │   └── ui/          # UI 组件
│   ├── scenes/          # 游戏场景/屏幕
│   │   ├── start-scene.ts
│   │   └── game-scene.ts
│   ├── main.ts          # 应用入口
│   └── types.ts         # 全局或共享类型
├── index.html
├── package.json
├── tsconfig.json
└── vite.config.ts
```

## 5. 数据格式约定

- **配置数据 (`gamedata/`)**: 使用 JSON 格式。每个对象（怪物、道具、装备、Buff）都有一个唯一的字符串 `id`。
  - `monsters`: 定义怪物的基础属性。
  - `items`: 定义可消耗或可使用的道具。
  - `equipments`: 定义可穿戴的装备及其属性加成。
  - `buffs`: 定义可应用于角色的增益或减益效果。
- **地图数据 (`mapdata/`)**: 使用 JSON 格式。包含 `layout` (二维数组定义基本地形) 和 `entities` (对象列表定义怪物、道具等实体的位置和ID)。
- **存档数据**: 使用 JSON 格式。记录游戏初始状态和玩家采取的每一步操作（Action）列表，以实现精确回放和状态恢复。

## 6. 装备系统规则

### 6.1 属性与计算
- **速度 (Speed)**: 新增的核心属性，用于决定战斗中的攻击顺序。速度高的单位先攻击。
- **装备属性**: 装备可以提供两类属性加成：
    - `stat_mods`: 提供固定数值的加减（如 `attack: 10`, `speed: -5`）。
    - `percent_mods`: 提供基于角色 **基础属性** 的百分比加减（如 `attack: 0.1` 表示增加10%的基础攻击力）。
- **属性下限**: 任何角色的任何属性（生命、攻击、防御、速度）在经过装备和Buff计算后，最终值不能低于 **1**。

### 6.2 装备更换逻辑
当玩家获得一件新装备时，系统会按以下规则自动处理：
1.  **空槽位**: 如果对应的装备槽是空的，则直接装备新物品。
2.  **纯粹提升**: 如果新装备提供的所有属性都 **优于或等于** 当前装备（无任何属性降低），则自动更换。旧装备会被移入备用装备栏。
3.  **纯粹降低**: 如果新装备提供的所有属性都 **劣于或等于** 当前装备（无任何属性提升），则自动丢弃新装备。
4.  **混合变化**: 如果新装备的属性有增有减，系统会 **弹出对话框**，显示详细的属性变化，由玩家决定是否更换。
5.  **特殊情况 (武器)**: 任何涉及 **单手武器(1H)与双手武器(2H)之间** 的替换，都将 **强制弹出对话框**，让玩家清晰地看到2件单手武器与1件双手武器之间的数值差异。

## 7. 开发流程

我们将遵循 `jules/` 目录下的计划文件，分阶段进行开发。从项目搭建、核心逻辑、数据加载，到渲染、UI、存档等功能，逐步完成。每个阶段都将包含充分的测试。

## 8. 当前开发状态

项目已完成大部分计划的开发任务，包括核心玩法、UI、存档、特殊道具和效果等。

- **已完成**:
    - `plan001` - `plan015`: 全部开发计划均已完成。
    - `plan017` - `plan019`: 已完成。
    - `plan020`: 已完成。

- **下一个任务建议**:
    - `plan016`: "优化 Renderer 渲染性能".

- **未开始**:
    - `plan016`

开发仍在进行中。

## 9. Assets 规则

为了支持新的渲染机制，所有非背景的静态资源（如角色、怪物、道具、墙壁）需遵循以下规则：

- **渲染尺寸**: 所有实体（角色、怪物、道具、墙壁）均以其 **原始PNG像素尺寸** 进行渲染，不做任何缩放。
- **美术规范**: 这条规则给予美术对角色尺寸的完全控制。例如，一个 `65x130` 像素的PNG将精确地渲染为65x130像素。若要制作一个更“胖”的角色（例如86像素宽），美术只需提供一个86像素宽的PNG文件，它就会在游戏中占据相应的视觉空间，实现“超框”效果。
- **渲染基准**: 所有图片资源在渲染时将采用 **底部居中** 的对齐方式 (`anchor: 0.5, 1`)。无论图片尺寸如何，它们的“脚”都会被精确地放置在逻辑地块的底边中心。
- **默认朝向**: 所有角色的美术资源 (`player`, `monster`) 默认朝向 **右方**。游戏引擎会根据角色的 `direction` 状态（`'left'` 或 `'right'`）自动水平翻转图片以显示朝左的姿态。

## 10. 资源命名与地图处理说明

项目中资源（assets）别名与加载规则，现将关键约定记录于此：

- **资源别名规则**：`<type>_<filename>` 或 顶层 `filename`（例如：`monster_monster`, `item_item`, `player`）。
- **renderer 使用**：`import.meta.glob` 自动生成 manifest，alias 按上述规则生成。
- **gamedata 优先字段**：`gamedata` 中新增 `assetId` 字段，渲染与校验逻辑优先使用 `assetId`；若缺失则回退到 `id` 字段。
- **map 贴图映射**: `mapdata` 中的 JSON 文件现在包含 `tileAssets` 字段，该字段将 `layout` 中的数字直接映射到 `assetId`。这取代了旧的基于别名的回退逻辑，使得地图渲染更加明确和可维护。

## 11. 浮动文字系统 (Floating Text System)

为了统一处理游戏中的浮动文字效果（如伤害、治疗、道具拾取等），项目引入了 `FloatingTextManager`。

### 11.1 设计目标
- **集中管理**: 所有浮动文字的创建和动画都由该管理器负责。
- **队列机制**: 自动处理多个文字同时触发的情况，按顺序播放动画，避免重叠。
- **样式统一**: 通过预设的类型来控制文字的样式（颜色、大小等），方便统一修改和扩展。

### 11.2 如何使用

`FloatingTextManager` 已在 `Renderer` 中实例化。在游戏的其他部分（如 `GameScene`）中，可以通过 `Renderer` 的公共方法来调用。

**主要方法**:
1.  `renderer.showPlayerFloatingText(text, type)`: 在玩家头顶显示浮动文字。
2.  `renderer.floatingTextManager.add(text, type, position)`: 在指定位置显示浮动文字（主要用于对敌人造成伤害等情况）。

**类型 (`FloatingTextType`)**:
-   `'DAMAGE'`: 红色，用于伤害数值。
-   `'HEAL'`: 绿色，用于恢复效果。
-   `'ITEM_GAIN'`: 黄色，用于道具/钥匙获取。
-   `'STAT_INCREASE'`: 橙色，用于永久属性提升。

**示例: 在 `GameScene` 中显示道具获取信息**
```typescript
// 当玩家拾取道具后
const item = state.items[itemId];
if (item) {
    this.renderer.showPlayerFloatingText(`+1 ${item.name}`, 'ITEM_GAIN');
}
```

在开始下一个任务之前，请验证当前代码库的稳定性和功能完整性。

## 12. 地图生成器工具 (Map Generator Tool)

项目包含一个命令行工具，用于程序化生成地图布局数据。

### 12.1 功能
该工具可以根据指定的参数（如地图尺寸、区域数量、区域连接关系等）生成一个随机的、由墙和地板组成的迷宫布局。核心功能是通过递归分割算法将地图划分为多个区域，并在区域间创建门。

### 12.2 如何使用
1.  **修改参数**: 打开 `scripts/gen-map.ts` 文件，在 `main` 函数中找到 `exampleParams` 对象，根据需要修改其中的参数。
    - `Width`, `Height`: 地图的宽高。
    - `AreaNum`: 要划分的区域数量。
    - `LinkData`: 定义区域之间的连接（门）。例如 `[[0, 1]]` 表示在区域0和区域1之间创建一扇门。
    - `minAreaSize`: 定义每个区域的最小尺寸。例如 `{ 0: [5, 5] }` 表示区域0的最小宽高为5x5。
    - `mapAreaPos`: 强制某些坐标点必须位于特定区域内。例如 `{ 1: [[10, 10]] }` 表示坐标(10,10)必须在区域1中。
    - `outputFilename`: 生成的地图JSON文件的名称。

2.  **运行脚本**: 在项目根目录下，执行以下命令：
    ```bash
    npm run gen-map
    ```

3.  **查看结果**: 脚本执行成功后，会在 `mapdata/` 目录下生成指定的JSON文件。该文件可直接被游戏加载使用。
