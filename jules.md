# 项目概要：魔塔 (Project Tower)

## 1. 项目目标

开发一款基于 Pixi.js 和 TypeScript 的网页版魔塔类游戏。游戏核心玩法是玩家在俯视视角的迷宫中探索，通过策略性地击败怪物、收集道具和钥匙来不断挑战更高层。游戏为竖屏手机端设计，无随机性，强调资源管理的策略规划。

## 2. 核心设计原则

- **逻辑与渲染彻底分离**: 游戏核心逻辑（状态管理、战斗计算、道具效果）必须独立于渲染引擎。逻辑层不应包含任何 Pixi.js 或 DOM 的引用，以便未来能轻松迁移到客户端-服务器架构。
- **模块化**: 代码按功能划分为独立的模块/包（例如：`core-logic`, `renderer`, `data-management`）。单个文件不应过大，保持高内聚、低耦合。
- **数据驱动**: 所有游戏数据（怪物属性、道具效果、地图布局）均由外部 JSON 文件定义，方便策划调整数值和关卡设计。
- **确定性**: 游戏不包含任何随机因素。玩家以相同的顺序执行相同的操作，必须产生完全相同的结果。
- **可测试性**: 核心逻辑部分必须有高覆盖率的单元测试（目标 > 90%），以保证游戏规则的正确性和稳定性。
- **完整的类型定义**: 所有代码必须使用 TypeScript，并提供完整的类型定义，以增强代码的可维护性和健壮性。
- **详尽的注释**: 为关键函数、类和复杂的逻辑块编写清晰的 JSDoc 注释。

## 3. 技术栈

- **渲染引擎**: Pixi.js (最新版)
- **开发语言**: TypeScript
- **构建/打包工具**: Vite (推荐，启动快，支持 TS)
- **测试框架**: Vitest 或 Jest
- **代码规范**: ESLint + Prettier

## 4. 目录结构

```
.
├── assets/              # 游戏资源 (图片)
│   ├── item/
│   ├── map/
│   └── monster/
├── gamedata/            # 游戏数据配置 (JSON)
│   ├── buffs/           # 增益效果配置
│   ├── equipments/      # 装备配置
│   ├── items/           # 道具配置
│   └── monsters/        # 怪物配置
├── jules/               # Jules 的开发计划文件
│   ├── plan001.md
│   └── ...
├── mapdata/             # 地图数据 (JSON)
│   └── floor_01.json
├── public/              # 静态文件
├── src/                 # 源码
│   ├── core/            # 核心逻辑 (无渲染)
│   │   ├── state.ts     # 状态管理
│   │   ├── types.ts     # 核心类型定义
│   │   ├── logic.ts     # 战斗、道具等逻辑
│   │   └── tests/       # 单元测试
│   ├── data/            # 数据加载和管理
│   │   └── data-manager.ts
│   ├── renderer/        # 渲染层 (Pixi.js)
│   │   ├── renderer.ts
│   │   └── ui/          # UI 组件
│   ├── scenes/          # 游戏场景/屏幕
│   │   ├── start-scene.ts
│   │   └── game-scene.ts
│   ├── main.ts          # 应用入口
│   └── types.ts         # 全局或共享类型
├── index.html
├── package.json
├── tsconfig.json
└── vite.config.ts
```

## 5. 数据格式约定

- **配置数据 (`gamedata/`)**: 使用 JSON 格式。每个对象（怪物、道具、装备、Buff）都有一个唯一的字符串 `id`。
  - `monsters`: 定义怪物的基础属性。
  - `items`: 定义可消耗或可使用的道具。
  - `equipments`: 定义可穿戴的装备及其属性加成。
  - `buffs`: 定义可应用于角色的增益或减益效果。
- **地图数据 (`mapdata/`)**: 使用 JSON 格式。包含 `layout` (二维数组定义基本地形) 和 `entities` (对象列表定义怪物、道具等实体的位置和ID)。
- **存档数据**: 使用 JSON 格式。记录游戏初始状态和玩家采取的每一步操作（Action）列表，以实现精确回放和状态恢复。

## 6. 装备系统规则

### 6.1 属性与计算
- **速度 (Speed)**: 新增的核心属性，用于决定战斗中的攻击顺序。速度高的单位先攻击。
- **装备属性**: 装备可以提供两类属性加成：
    - `stat_mods`: 提供固定数值的加减（如 `attack: 10`, `speed: -5`）。
    - `percent_mods`: 提供基于角色 **基础属性** 的百分比加减（如 `attack: 0.1` 表示增加10%的基础攻击力）。
- **属性下限**: 任何角色的任何属性（生命、攻击、防御、速度）在经过装备和Buff计算后，最终值不能低于 **1**。

### 6.2 装备更换逻辑
当玩家获得一件新装备时，系统会按以下规则自动处理：
1.  **空槽位**: 如果对应的装备槽是空的，则直接装备新物品。
2.  **纯粹提升**: 如果新装备提供的所有属性都 **优于或等于** 当前装备（无任何属性降低），则自动更换。旧装备会被移入备用装备栏。
3.  **纯粹降低**: 如果新装备提供的所有属性都 **劣于或等于** 当前装备（无任何属性提升），则自动丢弃新装备。
4.  **混合变化**: 如果新装备的属性有增有减，系统会 **弹出对话框**，显示详细的属性变化，由玩家决定是否更换。
5.  **特殊情况 (武器)**: 任何涉及 **单手武器(1H)与双手武器(2H)之间** 的替换，都将 **强制弹出对话框**，让玩家清晰地看到2件单手武器与1件双手武器之间的数值差异。

## 7. 开发流程

我们将遵循 `jules/` 目录下的计划文件，分阶段进行开发。从项目搭建、核心逻辑、数据加载，到渲染、UI、存档等功能，逐步完成。每个阶段都将包含充分的测试。

## 8. 当前开发状态

项目已完成所有计划的开发任务，包括核心玩法、UI、存档、特殊道具和效果等。游戏功能已全部实现。

- **已完成**:
    - `plan001` - `plan015`: 全部开发计划均已完成。

- **下一个任务建议**:
    - **项目收尾**: 所有开发计划已完成。建议进行最终的全面测试、打包构建，并准备部署。

- **未开始**:
    - (暂无)

整体开发已完成，项目进入最终测试和部署准备阶段。

## 9. Assets 规则

为了支持新的渲染机制，所有非背景的静态资源（如角色、怪物、道具、墙壁）需遵循以下规则：

- **渲染尺寸**: 所有实体（角色、怪物、道具、墙壁）均以其 **原始PNG像素尺寸** 进行渲染，不做任何缩放。
- **美术规范**: 这条规则给予美术对角色尺寸的完全控制。例如，一个 `65x130` 像素的PNG将精确地渲染为65x130像素。若要制作一个更“胖”的角色（例如86像素宽），美术只需提供一个86像素宽的PNG文件，它就会在游戏中占据相应的视觉空间，实现“超框”效果。
- **渲染基准**: 所有图片资源在渲染时将采用 **底部居中** 的对齐方式 (`anchor: 0.5, 1`)。无论图片尺寸如何，它们的“脚”都会被精确地放置在逻辑地块的底边中心。
- **默认朝向**: 所有角色的美术资源 (`player`, `monster`) 默认朝向 **右方**。游戏引擎会根据角色的 `direction` 状态（`'left'` 或 `'right'`）自动水平翻转图片以显示朝左的姿态。

## 10. 资源命名与地图处理说明

项目中资源（assets）别名与加载规则，现将关键约定记录于此：

- **资源别名规则**：`<type>_<filename>` 或 顶层 `filename`（例如：`monster_monster`, `item_item`, `player`）。
- **renderer 使用**：`import.meta.glob` 自动生成 manifest，alias 按上述规则生成。
- **gamedata 优先字段**：`gamedata` 中新增 `assetId` 字段，渲染与校验逻辑优先使用 `assetId`；若缺失则回退到 `id` 字段。

注意：目前 `map` 的贴图处理使用的是一个临时方案（`renderer` 中加入了 `resolveTextureAlias` 并尝试 `map_floor` 等别名）；后续计划将 `map` JSON 扩展一个字段，用于把 `layout` 中的数字映射到 `assetId`（而 `assets/map` 下的图片仍按 `map_<filename>` 的规则命名）。该变更计划已编入 `jules/plan018.md`，准备在后续迭代中实施。

在开始下一个任务之前，请验证当前代码库的稳定性和功能完整性。
