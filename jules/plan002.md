# 计划 002: 核心游戏逻辑与状态管理

## 目标

实现游戏的核心机制，包括状态管理、实体属性、战斗系统和基本互动逻辑。**此阶段完全不涉及任何图形或渲染代码**，以确保逻辑层的独立性。所有功能都将通过单元测试进行验证。

## 主要任务

1.  **定义核心类型 (`src/core/types.ts`)**:
    - `IPlayer`, `IMonster`, `IItem`: 定义角色、怪物和道具的属性接口（如 `id`, `name`, `hp`, `attack`, `defense` 等）。
    - `EntityType`: `enum` 类型，用于区分不同实体（`PLAYER`, `MONSTER`, `ITEM`, `EMPTY`）。
    - `Tile`: 定义地图单元格的结构，包含 `groundLayer` 和 `entityLayer`。
    - `GameState`: 定义整个游戏世界的状态，包括当前楼层、地图数据、玩家状态、实体列表等。
    - `Action`: 定义一个操作的接口（如 `{ type: 'MOVE', payload: { dx: number, dy: number } }`）。这是实现撤销和存档回放的关键。

2.  **实现状态管理器 (`src/core/state.ts`)**:
    - 创建 `GameStateManager` 类。
    - 负责初始化游戏状态（`initializeState`）。
    - 提供查询当前状态的方法（`getState`）。
    - 实现一个 `dispatch(action: Action)` 方法。此方法是更新游戏状态的唯一入口。它会根据 `action` 类型调用相应的逻辑处理器。

3.  **实现游戏逻辑 (`src/core/logic.ts`)**:
    - **移动逻辑**: 处理 `MOVE` action。检查目标位置是否可通行（例如，不是墙壁）。如果目标位置有怪物，则触发战斗；如果有道具，则拾取。
    - **战斗逻辑**:
        - `calculateBattleOutcome`: 一个纯函数，输入玩家和怪物，返回战斗结果（如玩家损失的 HP、怪物是否被击败）。
        - 逻辑应遵循：伤害 = `max(0, 攻击者攻击 - 防御者防御)`。
        - 处理特殊怪物技能（如攻击后回血）。
    - **道具逻辑**: 处理 `PICK_UP_ITEM` action。根据道具类型更新玩家属性（例如，增加 HP、攻击力、获得钥匙）。
    - **开门逻辑**: 处理 `OPEN_DOOR` action。检查玩家是否有对应颜色的钥匙，如果有则消耗钥匙并移除门。

4.  **编写单元测试 (`src/core/tests/`)**:
    - 为 `logic.ts` 中的所有函数编写测试。
    - **测试战斗**: 模拟不同攻防数值的战斗，验证伤害计算是否正确。
    - **测试移动**: 验证玩家移动到空格、墙、怪物和道具上的行为是否符合预期。
    - **测试道具**: 验证拾取不同道具后，玩家状态是否正确更新。
    - **测试开门**: 验证钥匙的消耗和门的状态变化。
    - **目标**: 核心逻辑的测试覆盖率达到 90% 以上。

## 验收标准

- 所有核心数据结构和类型定义完整。
- `GameStateManager` 能够正确地初始化和更新游戏状态。
- `dispatch` 方法能够根据不同的 `Action` 路由到正确的逻辑处理函数。
- 所有的战斗、移动、道具和开门逻辑都已实现并通过单元测试。
- 单元测试覆盖率满足预定目标（>90%），并且所有测试用例都能成功通过。
- 整个 `src/core` 目录中没有任何对 `pixi.js` 或浏览器 API 的依赖。
